// Директива let объявляет переменную с блочной областью видимости с возможностью инициализировать её значением
// Синтаксис:
let var1 = value1 , var2 = value2 , varN = valueN;
// где 
var1, var2, varN  //Имя переменной. Может использоваться любой допустимый идентификатор.
value1, value2, valueN //Значение переменной. Любое допустимое выражение.

// Директива let позволяет объявить локальную переменную с областью видимости, ограниченной
// текущим блоком кода . В отличие от ключевого слова var, которое объявляет переменную
// глобально или локально во всей функции, независимо от области блока.

// Областью видимости переменных, объявленных ключевым словом let, является блок, в котором
// они объявлены, и все его подблоки. В этом работа директива let схожа с работой директивы var
// Основная разница заключается в том, что областью видимости переменной, объявленной
// директивой var, является вся функция, в которой она объявлена:

function varTest() {
    var x = 1;
    if (true) {
      var x = 2;  // та же переменная!
      console.log(x);  // 2
    }
    console.log(x);  // 2
  }
  
  function letTest() {
    let x = 1;
    if (true) {
      let x = 2;  // другая переменная
      console.log(x);  // 2
    }
    console.log(x);  // 1
  }

//   Временные мертвые зоны и ошибки при использовании let

// В стандарте ECMAScript 2015 переменные, объявленные директивой let, переносятся в
// начало блока. Но если вы сошлетесь в блоке на переменную, до того как она объявлена директивой
// let, то это приведет к выбросу исключения ReferenceError, потому что переменная находится во
// "временной мертвой зоне" с начала блока и до места ее объявления. (В отличии от переменной,
// объявленной через var, которая просто будет содержать значение undefined)

function do_something() {
    console.log(bar); // undefined
    console.log(foo); // ReferenceError: foo is not defined
    var bar = 1;
    let foo = 2;
  }

//   Вы можете столкнуться с ошибкой в операторах блока  switch, так как он имеет только один подблок.

switch (x) {
    case 0:
      let foo;
      break;
  
    case 1:
      let foo; // Выброс SyntaxError из-за повторного объявления переменной
      break;
  }

//   let vs var

// Когда let используется внутри блока, то область видимости переменной ограничивается этим
// блоком. Напомним, что отличие заключается в том, что областью видимости переменных,
// объявленных директивой var, является вся функция, в которой они были объявлены.

var a = 5;
var b = 10;

if (a === 5) {
  let a = 4; // The scope is inside the if-block
  var b = 1; // The scope is inside the function

  console.log(a);  // 4
  console.log(b);  // 1
}

console.log(a); // 5
console.log(b); // 1


// const

// Значение констант не может быть изменено новым присваиванием,
//  а также не может быть переопределено. Константы (const)
//  подчиняются области видимости уровня блока так же, как переменные,
//  объявленные с использованием ключевого слова let.

const name1 = value1

// Имя константы. Подчиняется тем же правилам, что и идентификаторы обычных переменных.
// Значение константы. Может быть любым из тех типов, которые могут быть для переменных, включая функцию.

// Это объявление создаёт константу, чья область действия может быть как глобальной, так и
// локальной внутри блока, в котором она объявлена. Глобальные константы не становятся
// свойствами объекта window, в отличие от var-переменных. Инициализация константы обязательна;
// необходимо указать значение одновременно с объявлением (смысл в том, что потом это значение
// изменить уже нельзя).

// const создаёт константу (новую именованную ссылку на область памяти), доступную только для
// чтения. Это не означает, что указываемое значение неизменно, но это означает, что идентификатор
// не может быть переназначен. Например, если константа указывает на объект, то сам объект может
// быть изменён.

// Все соображения по поводу временных мёртвых зон, применимы и к let и к const.

// Имена констант не могут совпадать с именами функций или переменных той же области видимости.
// =================================================================================================


// Map 

// Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет
// использовать ключи любого типа.

// Методы и свойства:

//  - new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из
//    пар [ключ,значение] для инициализации.

//  - map.set(key, value) – записывает по ключу key значение value.

//  - map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.

//  - map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.

//  - map.delete(key) – удаляет элемент по ключу key.

//  - map.clear() – очищает коллекцию от всех элементов.

//  - map.size – возвращает текущее количество элементов.

// Отличия от обычного объекта Object:
// Что угодно может быть ключом, в том числе и объекты.
// Есть дополнительные методы, свойство size.

// Для перебора коллекции Map есть 3 метода:

// - map.keys() – возвращает итерируемый объект по ключам

// - map.values() – возвращает итерируемый объект по значениям

// - map.entries() – возвращает итерируемый объект по парам вида [ключ, значение],
//   этот вариант используется по умолчанию в for..of.

let recipeMap = new Map([
    ["огурец", 500],
    ["помидор", 350],
    ["лук",    50]
  ]);
  
  // перебор по ключам (овощи)
  for (let vegetable of recipeMap.keys()) {
    alert(vegetable); // огурец, помидор, лук
  }
  
  // перебор по значениям (числа)
  for (let amount of recipeMap.values()) {
    alert(amount); // 500, 350, 50
  }
  
  // перебор по элементам в формате [ключ, значение]
  for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
    alert(entry); // огурец,500 (и так далее)
  }

//  ! Используется порядок вставки

//  В отличие от обычных объектов Object,
//  в Map перебор происходит в том же порядке, в каком происходило добавление элементов.

// Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:
// выполняем функцию для каждой пары (ключ, значение)

recipeMap.forEach((value, key, map) => {
    alert(`${key}: ${value}`); // огурец: 500 и так далее
  });




// Set

// Объект Set – это особый вид коллекции:
//  «множество» значений (без ключей), где каждое значение может появляться только один раз.

// Его основные методы это:

//  - new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект
//    (обычно это массив), то копирует его значения в новый Set.

//  - set.add(value) – добавляет значение (если оно уже есть, то ничего не делает),
//    возвращает тот же объект set.

//  - set.delete(value) – удаляет значение, возвращает true,
//   если value было в множестве на момент вызова, иначе false.

//  - set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.

//  - set.clear() – удаляет все имеющиеся значения.

//  - set.size – возвращает количество элементов в множестве.

// Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach

let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});

// Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain,
//  и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

// Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента.
//  Выглядит немного странно, но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

// Set имеет те же встроенные методы, что и Map:

// - set.values() – возвращает перебираемый объект для значений,
// - set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
// - set.entries() – возвращает перебираемый объект для пар вида [значение, значение],
//   присутствует для обратной совместимости с Map.